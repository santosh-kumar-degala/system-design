What is Event-Driven Architecture (EDA)?

An event-driven system is a software architecture style where the flow of the program is determined by events.
An event is a significant change in state ‚Äî e.g., ‚Äúuser registered,‚Äù ‚Äúpayment processed,‚Äù ‚Äúfile uploaded.‚Äù
Instead of services calling each other directly (request/response), systems react to events as they happen.

Core Components
Event Producers (Publishers)
Detect a change in state and generate an event.
Example: An Order Service publishes OrderPlaced.

Event Channel (Broker/Bus)
Middleware that transports events.
Example: RabbitMQ, Kafka, Azure Service Bus, AWS SNS/SQS.

Event Consumers (Subscribers)
Listen for events and take action.
Example: A Notification Service consumes OrderPlaced and sends an email.

Characteristics
Asynchronous ‚Üí Producers don‚Äôt wait for consumers to act.
Loosely coupled ‚Üí Producers don‚Äôt know who is consuming.
Scalable ‚Üí Multiple consumers can process in parallel.
Reactive ‚Üí Services respond to state changes in real-time.

Example Flow 
üí° Let‚Äôs say a user places an order:

Order Service publishes an OrderPlaced event.
Inventory Service consumes it ‚Üí reduces stock.
Billing Service consumes it ‚Üí charges payment.
Notification Service consumes it ‚Üí sends confirmation email.

Each service reacts independently. 
If tomorrow you add a Fraud Detection Service, it just subscribes to OrderPlaced without modifying the publisher.

Why use Event-Driven?
Decouples services ‚Üí easier to scale and evolve.
Enables real-time processing.
Great for microservices, IoT, stream processing, and workflows.

‚úÖ In short: 
Event-driven = systems that react to state changes (events), using producers, consumers, and brokers, rather than direct synchronous calls.

Idempotency in event-driven systems
Goal: Ensure processing the same event multiple times does not cause incorrect side effects.

Idempotency keys: 
Consumer persists last-seen event ID (or request ID) per entity. 
If event ID already processed ‚Üí skip. 
Use a strongly consistent store for this (e.g., Redis with SETNX + TTL, or a DB table with unique constraint).

Upserts (PUT semantics): 
Design operations as upserts instead of incrementing. For example write state = event.state rather than state += delta.

Event deduplication at broker: 
Some brokers offer deduplication (e.g., Kafka idempotent producers, some managed brokers). But still handle dedupe at consumer.

Idempotent side-effects: 
Design side-effect operations to be reversible or check-before-act (e.g., send-email: check whether email_sent flag exists).

Write-ahead log / Outbox: 
Record event in a durable outbox with unique id before acknowledging DB write; consumers read outbox or downstream read from broker and dedupe.

Example pattern (pseudo):
Consumer receives event with event_id.
if processed_store.contains(event_id): ack and return
perform business operation (db upsert)
persist event_id to processed_store and ack.


Delivery semantics: at-most-once, at-least-once, exactly-once

Trade-offs
At-most-once: 
Messages delivered 0 or 1 time. Lowest duplication risk but can lose messages (no retries). Simple ‚Äî OK if occasional loss acceptable.

At-least-once:
Messages delivered 1 or more times. Ensures nothing lost but duplicates possible ‚Üí requires idempotency. Most common in distributed systems.

Exactly-once:
Guarantees single effective processing. Hard and costly. Achieved via transactional systems (Kafka transactions + idempotent producers + transactional consumer patterns), or using outbox pattern + atomic commit. For many systems, "effectively exactly once" is implemented via idempotency + dedupe.

When to choose
Critical financial transactions ‚Üí aim for exactly-once (or strong compensating transactions).
Analytics / telemetry ‚Üí at-least-once acceptable.
Notification (email) ‚Üí at-least-once + dedupe.


Event sourcing vs pub/sub

Event Sourcing
Model: 
State stored as immutable sequence of events. Rehydrate aggregates by replaying events.
Pros: 
Full audit trail, easy to rebuild state, good for complex domain logic, temporal queries.
Cons: 
Complexity (snapshots required), event versioning, eventual consistency concerns, higher storage/processing costs.

Pub/Sub (simple)
Model:
Events published to topics for asynchronous decoupling; state stored in DB; events used for integration and async tasks.
Pros:
Simpler, fewer constraints, widely applicable.
Cons: 
No single source-of-truth of past intents guaranteed; harder to rebuild full state from events if they are not the canonical source.

When to use
Use event sourcing for complex domain logic, auditability, or when you need to derive many different projections.
Use pub/sub where you only need async integrations, notifications, or decoupling.
